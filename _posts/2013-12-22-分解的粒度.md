---
layout: post
alias: the-scope-of-splitting-code
tags: Java
date: 2013-12-22 18:53:38
title: 分解的粒度
---

这篇日志真不好写，已经重写了两遍，每次都是写到一大半时，发现自己对于问题本质的理解不对，于是删了重写，内容也完全不同。希望这次能把它写完。

日志的起因是我们项目里需要写一个测试工具，我写的代码受到了同事的质疑，他认为我的方案要写太多的类，而且宁愿用`if...else`来做。

简单的说，这个测试工具，需要对不同Module的不同检查点进行检查。可以假设我们有下面一张表：

     ||---------------||---------------||---------------||------------------||
     || Module Name   ||  Dir Checker  ||  DB Checker   || Storage Checker  ||
     ||---------------||---------------||---------------||------------------||
     ||    ModuleA    ||       Y       ||     OK        ||    /aaa.xml      ||
     ||---------------||---------------||---------------||------------------||
     ||    ModuleB    ||       Y       ||     OK        ||    /bbb.xml      ||
     ||---------------||---------------||---------------||------------------||
     ||    ModuleC    ||       N       ||   FAILED      ||    /ccc.xml      ||
     ||---------------||---------------||---------------||------------------||
    

    我们的测试工具，需要读取这样的一个表，根据其内容对相应的Module和检查点进行检查。

    ## 我的方案

    我的方案是将每个Module的每个检查点，都作为一个独立的类。这样当以后有新的Module或检查点出现时，可以不用修改已有任何代码，只需要创建新类。

    对于上表中的ModuleA，定义了三个类:

    class ModuleADirChecker {
         void check(String shouldInOrNot);
    }
    class ModuleADbChecker {
         void check(String expectedStatus);
    }
    class ModuleAStorageChecker {
         void check(String remotePath);
    }
    

    对于ModuleB和C，也将会各有三个类，这样就会有9个类。

    如何将每个类与module/checkpoint匹配起来呢？最简单的方式是通过一堆`if...else...`来判断：

    public void getChecker(String module, String checkPoint) {
        if(module.equals("ModuleA")) {
             if(checkPoint.equals("Dir Checker")) {
                  return new ModuleADirChecker();
             } else if(checkPoint.equals("DB Checker")) {
                  return new ModuleADbChecker();
             } else if(checkPoint.equals("Storage Checker")) {
                  return new ModuleAStorageChecker();
             }
        } else if(module.equals("ModuleB")) {
             ...
        } else if(module.equals("ModuleC")) {
             ...
        }
    }
    

    我想到用注解，可以会让代码更加独立一些，于是写了一个`CheckerAnno`注解，这么用：

    @CheckerAnno(module="ModuleA", checkPoint="Dir Checker")
    class ModuleADirChecker {
         void check(String shouldInOrNot);
    }
    

    每个checker上，都放一个`CheckerAnno`，指示它匹配的是哪个module和checkPoint。在程序运行时，将会扫描代码，根据`CheckerAnno`中的数据，自动把各checker与excel表中的单元格匹配起来，生成实例，传入数据进行检查。这样我们就不需要写上面那个长长的`getChcker`方法了，并且以后添加新的Module或者Column时，也不需要修改**任何**已有代码。

    ## 同事的方案

    同事觉得我的方案不好，因为他觉得我的类太多了。而且他发现，某些检查点虽然要检查多个Module，但它们的逻辑非常相似。比如`Dir Checker`仅仅需要不同的Module提供一个不同的值，实际的检查逻辑是一样的。

    他给出的方案是：每个检查点一个类，在类里通过`if...else`来针对不同的Module做不同的检查。比如对于`DirChecker`，他是这么做的：

    class DirChecker {
        public void check(String moduleName, String shouldInOrNot) {
            File dir = getDir(moduleName);
            checkDir(dir, shouldInOrNot);
        }
        private File getDir(String moduleName) {
            if(moduleName.equal("ModuleA") {
                return localTempDirOfModuleA();
            } else if(moduleName.equals("ModuleB")) {
                return localTempDirOfModuleB();
            } else if(moduleName.equals("ModuleC")) {
                return localTempDirOfModuleC();
            } else {
                throw new IllegaArgumentException("Unknown module:" + moduleName);
            }
        }
    }
    

    对于其它的每一个检查点，也都需要定义一些这样的类，每个类中通过`if...else`来决定哪个Module进行哪种检查。

    我觉得他这种方式的关键，不在于是否使用了`if...else`，因为他也可以使用注解来实现，跟我那种一样：

    @CheckPoint("Dir Checker")
    class DirChecker {
        @CheckModule("ModuleA")
        public void check1(String shouldInOrNot) {
             ...
        }
        @CheckModule("ModuleB")
        public void check2(String shouldInOrNot) {
             ...
        }
        @CheckModule("ModuleC")
        public void check3(String shouldInOrNot) {
             ...
        }
    }
    

    然后可使用相同的方式扫描注解，将每个check方法与相应的module和checkpoint匹配起来。虽然每当增加一个新Module时，他需要修改已有的类，添加一个新的方法并加上相应的注解，但由于这样的方法相当于一个入口，不会修改已有的逻辑，所以也是可以接受的。

    ## 第三种方案

    可以很自然的想到第三种方式：以行为类。即为每个Module定义一个类，里面提供多个方法分别对应每个检查点。如果用注解的话，大约是这样的：

    @CheckerModule("ModuleA")
    class ModuleA {
        @CheckPoint("Dir Checker")
        public void check1(String shouldInOrNot) {}
        @CheckPoint("Db Checker")
        public void check2(String expectedStatus) {}
        @CheckPoint("Storage Checker")
        public void check3(String remotePath) {}
    }

## 问题的本质

所以问题的关键就在于粒度：对于这个例子，哪种粒度更好？行？列？还是单元格？

如果说这三种方案都是差不多的，随便选一个就行，那就省事了，看自己的喜好即可。否则的话，我应该以什么为考虑的重点，来决定采用哪一种粒度呢？

* * *

有同学说看不懂我在问什么。

的确我也感觉不知道自己在问什么，因为这个问题产生于真实的项目，很多影响我思考的因素也许在本文外，但我还没有意识到。从一个复杂项目中，把一个问题以最简方式完整的剥离出来，本身就是一件很难的事吧。如果真的能把所有有关联的因素抽出来了，所有没有关联的因素都留下了，也许答案自然就出来了，不需要再问了。

看来这个问题只能等我自己解决了。
